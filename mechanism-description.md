### Causal dependency tracking
Causal dependencies are tracked using vector clocks. When new keys are put to the store, the accepting node takes the causal metadata given in the request and compares with its internal vector clock. If the node sees that the passed metadata is in its causal past, it asks the required nodes to update its representation of the store. After the updates are completed as needed, the node updates its clock, and increments its position in the vector by one. The updated metadata is returned to the client, who can then perform further requests on other nodes using the new metadata. This process ensures that as long as the client continues to pass the causal metadata from the previous requests they made, the nodes will be able to tell whether they are outdated and should update their copy of the requested key.

### Detecting that a node is down
A view is maintained by all of the nodes that are currently up, as well as a master view containing all of the nodes in the VIEW environment variable. On node startup, the new node will attempt to ask all other nodes in the master view to add it to their view. When a node goes down and a request to that node is made by another, the request will time out. In this case, the node will adjust its view accordingly, and forward the information to the rest of the available nodes. This lets each node maintain a view of currently available nodes, as well as know which nodes it should attempt to contact on startup or recovery.

### Deciding how to shard keys across nodes
Keys are sharded across nodes by taking the MD5 hash of a key modulus the number of shards. This allows the shard of any key to be easily decided, but has the potential to move a large amount of data in the event that a node goes down.